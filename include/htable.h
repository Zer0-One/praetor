/*
* This source file is part of praetor, a free and open-source IRC bot,
* designed to be robust, portable, and easily extensible.
*
* Copyright (c) 2015-2017 David Zero
* All rights reserved.
*
* The following code is licensed for use, modification, and redistribution
* according to the terms of the Revised BSD License. The text of this license
* can be found in the "LICENSE" file bundled with this source distribution.
*/

#ifndef PRAETOR_HTABLE
#define PRAETOR_HTABLE

#include <stdbool.h>
#include <stdint.h>

/**
 * The htable struct represents a chaining hash table. Keys are hashed using
 * Bob Jenkins's one-at-a-time hash algorithm.
 */
struct htable;

struct htable_key{
    /**
     * The size of \c key in units of uint8_t.
     */
    size_t key_size;
    /**
     * A copy of a key stored within the table.
     */
    uint8_t key[];
};

/**
 * Creates a new hash table with \c size buckets.
 *
 * The created table will maintain its original size until its load-factor
 * reaches a particular threshold (.75 by default), at which point the table
 * will be doubled in size to accommodate additional mappings.
 *
 * \return A pointer to the newly-created table on success.
 * \return NULL if \c size is 0, or the system is out of memory.
 */
struct htable* htable_create(size_t size);

/**
 * Destroys the given hash table, freeing all associated memory.
 */
void htable_destroy(struct htable* table);

/**
 * Adds a key-value mapping to the given table.
 *
 * If a mapping for the given key already exists within the table, this
 * function will leave the existing mapping unmodified, and return -1.
 *
 * \param key_size The size of the given key in units of uint8_t.
 *
 * \return 0 on success.
 * \return -1 if a mapping for the given key already exists.
 * \return -2 if the system was out of memory.
 */
int htable_add(struct htable* table, const uint8_t* key, size_t key_size, void* value);

/**
 * Removes the mapping for the given key from the table.
 *
 * \param key_size The size of the given key in units of uint8_t.
 *
 * \return 0 on success.
 * \return -1 if there was no mapping for the given key, or if any of the
 *         parameters are NULL/0.
 */
int htable_remove(struct htable* table, const uint8_t* key, size_t key_size);

/**
 * Performs a lookup for a mapping with the given key.
 *
 * \param key_size The size of the given key in units of uint8_t.
 *
 * \return A pointer to the value mapped to the given key on success.
 * \return NULL if there was no mapping for the given key, or if any of the
 *         parameters were NULL or 0.
 */
void* htable_lookup(const struct htable* table, const uint8_t* key, size_t key_size);

/**
 * Generates an array of keys contained within the given table.
 *
 * The keys present in the returned array are copies of the keys contained
 * within the table, and may be modified in-place.
 *
 * \param[out] size A pointer to a size_t in which the number of elements in the
 *                  array will be returned.
 *
 * \return An array of all keys present within the table on success.
 * \return NULL if the system is out of memory, if \c table is NULL, or if the
 *         given table holds no entries.
 */
struct htable_key** htable_get_keys(const struct htable* table, size_t* size);

/**
 * Frees the memory associated with an array generated by htable_get_keys().
 *
 * On completion, this function will invalidate the \c keys pointer.
 *
 * \param size The number of htable_key elements within the array. If this
 * value is larger than the actual size of the array, this function will result
 * in undefined behavior. If this value is smaller than the actual size of the
 * array, this function will leak memory.
 */
void htable_key_list_free(struct htable_key** keys, size_t size);

/**
 * Calculates and returns the current load-factor of the specified hash table.
 * The load factor is given by \f$(n/k)\f$, where \f$n\f$ is the number of
 * key-value mappings, and \f$k\f$ is the number of buckets.
 */
double htable_get_load_factor(const struct htable* table);

/**
 * Returns the load-factor at which the table will automatically resize itself.
 */
double htable_get_load_threshold(const struct htable* table);

/**
 * Sets the load-factor at which the table will automatically resize itself.
 * 
 * \param threshold If the given threshold is either 0 or a negative value, the
 * table will double in size with every addition. If the given threshold is
 * larger than 1, performance of the hash table may be severely degraded.
 */
void htable_set_load_threshold(struct htable* table, double threshold);

/**
 * Returns the number of key-value mappings stored within the table.
 */
size_t htable_get_mapping_count(const struct htable* table);

/**
 * Returns the number of buckets stored within the table.
 */
size_t htable_get_bucket_count(const struct htable* table);

#endif
